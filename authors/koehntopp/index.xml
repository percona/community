<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Percona Community</title><link>https://percona.community/authors/koehntopp/</link><description>Recent content on Percona Community</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Percona Community. MySQL, InnoDB, MariaDB and MongoDB are trademarks of their respective owners.</copyright><lastBuildDate>Mon, 04 Jan 2021 16:06:48 +0000</lastBuildDate><atom:link href="https://percona.community/authors/koehntopp/index.xml" rel="self" type="application/rss+xml"/><item><title>fork, exec, wait and exit</title><link>https://percona.community/blog/2021/01/04/fork-exec-wait-and-exit/</link><pubDate>Mon, 04 Jan 2021 16:06:48 +0000</pubDate><guid>https://percona.community/blog/2021/01/04/fork-exec-wait-and-exit/</guid><description>This is the english version of a 2007 article. In de.comp.os.unix.linux.misc somebody asked:
Are commands in a script executed strictly sequentially, that is, will the next command only be executed when the previous command has completed, or will the shell automatically start the next command if the system has spare capacity? Can I change the default behavior - whatever it may be - in any way? If you are looking into the fine manual, it may explain at some point that the shell starts each command in a separate process.</description></item><item><title>Embracing the Stream</title><link>https://percona.community/blog/2020/12/10/embracing-the-stream/</link><pubDate>Thu, 10 Dec 2020 10:33:29 +0000</pubDate><guid>https://percona.community/blog/2020/12/10/embracing-the-stream/</guid><description>So this happened: CentOS Project shifts focus to CentOS Stream
The future of the CentOS Project is CentOS Stream, and over the next year we’ll be shifting focus from CentOS Linux, the rebuild of Red Hat Enterprise Linux (RHEL), to CentOS Stream, which tracks just ahead of a current RHEL release. CentOS Linux 8, as a rebuild of RHEL 8, will end at the end of 2021. CentOS Stream continues after that date, serving as the upstream (development) branch of Red Hat Enterprise Linux.</description></item><item><title>Not JOINing on PERFORMANCE_SCHEMA</title><link>https://percona.community/blog/2020/12/01/not-joining-on-performance_schema/</link><pubDate>Tue, 01 Dec 2020 19:22:46 +0000</pubDate><guid>https://percona.community/blog/2020/12/01/not-joining-on-performance_schema/</guid><description>The tables in PERFORMANCE_SCHEMA (P_S) are not actually tables. You should not think of them as tables, even if your SQL works on them. You should not JOIN them, and you should not GROUP or ORDER BY them.
Unlocked memory buffers without indexes The stuff in P_S has been created with “keep the impact on production small” in mind. That is, from a users point of view, you can think of them as unlocked memory buffers - the values in there change as you look at them, and there are precisely zero stability guarantees.</description></item><item><title>On the Observability of Outliers</title><link>https://percona.community/blog/2020/11/23/on-the-observability-of-outliers/</link><pubDate>Mon, 23 Nov 2020 17:41:16 +0000</pubDate><guid>https://percona.community/blog/2020/11/23/on-the-observability-of-outliers/</guid><description>At work, I am in an ongoing discussion with a number of people on the Observability of Outliers. It started with the age-old question “How do I find slow queries in my application?” aka “What would I want from tooling to get that data and where should that tooling sit?”
As a developer, I just want to automatically identify and isolate slow queries!
Where I work, we do have SolarWinds Database Performance Monitor aka Vividcortex to find slow queries, so that helps.</description></item></channel></rss>